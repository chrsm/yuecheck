import 'yuecheck.macros' as { $ }

import 'lpegrex' as lp
import 'inspect'

import 'yuecheck.types'
import 'yuecheck.util'

-- see:
--   * https://github.com/edubart/lpegrex/blob/main/parsers/lua.lua
--   * https://github.com/IppClub/YueScript/blob/main/src/yuescript/yue_parser.cpp#L50
--   * https://github.com/IppClub/YueScript/blob/main/src/yuescript/yue_parser.cpp#L990
-- note that this is *purely* for comments!
grammar = [===[
File                <== (Nodes / .)*
Nodes               <-- (Comment / String)
Comment             <-- (YueMultilineComment / YueLineComment)

YueLineComment      <== ('--' (!EOL .)*)
YueMultilineComment <== ('--[' {:level:('='*):} '[' ( !(']' =level ']') . )* ']' =level $']')

-- need string defined so that we do not include comments that are inside of them
String      <-- (StringShort / StringLong)
StringShort <- ('"' ( !'"' ('\\.' / . ) )* '"' /
                   "'" ( !"'" ('\\.' / . ) )* "'")->0
StringLong  <- ('[' {:level:('='*):} '[' ( !(']' =level ']') .)* ']' =level $']')->0

EOL <- %cn %cr / %cr %cn / %cn / %cr
EOF <- !.
]===]


pat = lp.compile grammar

matcher = (src, name) ->
  name or= 'src'

  ast, errlabel, errpos = pat\match src
  unless ast
    ln, col, srcline = lp.calcline src, errpos
    colhelp = "#{ string.rep ' ', col - 1 }^"
    msg = errlabel
    -- TODO: pass this up
    error "syntax error: #{ name }:#{ ln }:#{ col }: #{ msg }\n#{ srcline }\n#{ colhelp }"
  ast

to_ast = (src) ->
  ast, errlabel, errpos = matcher src, 'src'
  unless ast
    return { errlabel, errpos }

  comments = { indices: {} }
  for v in *ast
    content = src\sub v.pos, v.endpos
    line, col, c, lnst, lnend = lp.calcline src, v.pos

    t = nil
    switch v.tag
      when 'YueMultilineComment'
        t = types.YueMultilineComment content
      when 'YueLineComment'
        t = types.YueLineComment util.stripnl content
      else
        -- should never happen unless this isn't kept up-to-date with grammar
        error "unexpected comment type: #{ v.tag }"

    t\set_source line, col
    unless comments[line]
      comments[line] = {}
    comments[line][] = t
    comments.indices[] = line

  -- remove dup lines
  comments.indices = util.dedup comments.indices
  table.sort comments.indices

  comments

comments_between = (comments, p1, p2) ->
  -- we already know indices
  r =
    indices: []

  for v in *comments.indices
    if v >= p1 and v <= p2
      r.indices[] = v
      r[v] = {}

      for c in *comments[v]
        r[v][] = c
  r

export default {
  :matcher
  :to_ast
  :comments_between
}
