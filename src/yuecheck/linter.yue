import 'yue'

import 'yuecheck.ast' as ast
import 'yuecheck.comments' as ycomments
import 'yuecheck.rule'
import 'yuecheck.rules'
import 'yuecheck.types'
import 'yuecheck.util'

ruleset = { k, v for k, v in pairs rules }

linter =
  enable_compilation: false
  enabled_rules: { k,true for k,_ in pairs rules }

linter.define_rule = (t) ->
  unless t and type(t) == 'table'
    error 'define_rule: argument must be a table'
  unless t.name
    error 'define_rule: rule must have a name'
  unless t.on and type(t.on) == 'table'
    error 'define_rule: on must be a table'
  unless t.check and type(t.check) == 'function'
    error 'define_rule: check must be a function'
  ruleset[t.name] = t

linter.to_ast = (src) ->
  node, err = ast.parse src
  unless node
    error err
  node

linter.build_ast = ast.build

linter.lint_file = (path) ->
  fp, err = io.open path, 'r'
  content = fp\read 'a*'
  fp\close!

  linter.lint_string content

linter.lint_string = (src) ->
  raw_ast, err = yue.to_ast src, 0

  -- try to be helpful for syntax errors that prevent anything else from
  -- being done
  -- if the caret is there, it gives a pointer to the column (kinda)
  -- unsure if this is done in every case, so don't rely on it
  if err
    col = 0
    cpos = err\match '(%s+%^)$'
    if cpos and (cpos\sub 1, 1) == "\n"
      col = #cpos - 2

    err = err\gsub "\n", ' '
    line = err\match '^(%d+):'
    part = err\match ': (.+)^$'
    message = (part ?? err)\gsub '^%s*(.-)%s*$', '%1'
    return {{ type: 'ERROR', :line, :col, :message }}

  violations = {}

  -- @NOTE(chrsm):
  -- there are some things to_ast doesn't care about, for example `const`:
  --   yue.to_ast "const x = 1\nx = 2", 0
  -- is perfectly valid, but a runtime/comp error.
  -- if the user has set `enable_compilation`, we will check for errors here
  -- by running `yue -p <f>`, which prints code to stdout.
  --
  -- the _potential_ problem here is that macros are run at this time.
  -- macros can have side effects - not that they should, but they can,
  -- for instance, run `os.execute "rm -rf /"`. which would be very bad.
  -- it _might_ be enough to refuse to run this if macros are used.
  -- i don't really know.
  --
  -- the 'neat'? thing is we can probably use the ast to catch some of these,
  -- since the attrib exists, and skip doing this at some point.
  if linter.enable_compilation
    tmpname = os.tmpname!
    cmd = "yue -- 2>&1 > #{ tmpname }" -- popen is a bit annoying, can't do stdin+stdout
    ok, _, _ = util.exec_cmd_w cmd, stdin: src

    unless ok
      tmp = util.readfile tmpname
      col = 0
      cpos = tmp\match '(%s+%^)$'
      if cpos and (cpos\sub 1, 1) == "\n"
        col = #cpos - 2

      err = tmp\gsub "\n", ' '
      line = tmp\match '^(%d+):'
      message = (tmp\match ': (.+)^')\gsub '^%s*(.-)%s*$', '%1'
      violations[] = { type: 'ERROR', :message, :line, :col }

    os.remove tmpname

  nodes = ast.build raw_ast

  comments = (linter.find_comments src) or {}
  ignored = (line) ->
    unless comments[line]
      return
    m = false
    for ln in *comments[line]
      m = ln.v\match 'yuecheck:ignore'
      break if m
    m

  -- disabled linters should only apply to this specific source,
  -- otherwise we turn them off everywhere
  local rules = {}
  for k, v in pairs linter.enabled_rules
    rules[k] = v

  -- special ignore for whole file suppression;
  -- should make this more elegant.
  if comments[1]?
    cmt = comments[1][1].v
    if cmt\match '^-- yuecheck:ignore$'
      rules = {}
    m = cmt\match '-- yuecheck:ignore=([^\r\n%s]+)'
    if m
      for r in m\gmatch '([^,]+)'
        rules[r] = nil

  -- run a single rule against a node, collecting violations
  run_rule = (k, node) ->
    _rule = ruleset[k]
    r = nil
    if _rule.__class and (_rule.__class == rule.Rule or _rule.__class.__parent == rule.Rule)
      r = _rule\check node
    else
      r = _rule.check node
    if r != nil and not ignored r.line
      if r[1] -- it's a table of violations
        violations[] = _r for _r in *r
      else
        violations[] = r

  -- check if rule applies to this node type
  rule_matches = (k, node) ->
    for ntype in *ruleset[k].on
      if type(ntype) == 'string'
        ntype = types[ntype]
      if node.__class == ntype
        return true
    false

  -- walk and apply rules to nodes
  apply_rules = (node) ->
    if node == nil
      error 'nil node'
    for k, v in pairs rules
      continue unless v
      continue unless rule_matches k, node
      run_rule k, node

  -- walk the comments; there's at least one rule that cares
  for i in *comments.indices
    for cmt in *comments[i]
      cmt\walk apply_rules

  nodes\walk apply_rules

  violations

-- find_comments returns { line, comment } for a given string, which may be a
-- single line or multiple (e.g. whole file).
--
-- this does *NOT* check the provided src via to_ast, as the ast does not
-- preserve all comments. instead, simple patterns are used to find matches.
--
-- this should find all comments, even if they would have been attached to
-- a statement.
--
-- returns a table where line numbers map to comments.
linter.find_comments = (src) ->
  ycomments.to_ast src

export default linter
